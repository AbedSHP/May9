// da_round

global proc int da_round(float $ANum){
    float $n = $ANum % 1;
    if ($n >= 0.5) {
    $ANum = `ceil $ANum`;
    } else {
    $ANum = `floor $ANum`;
    }
    return $ANum;
}


// da_commonObjectOptionsPopup

global proc da_commonObjectOptionsPopup(){

string $panel = `getPanel -wf`;

menuItem
    -l "Visibility" 
    -subMenu 1
    -rp "NE" 
	-i "RS_visible.png";

menuItem
    -l "Curves" 
    -c "da_ToggleNurbsCurvesVis" 
	-cb (`modelEditor -q -nurbsCurves $panel`)
    -rp "NE";

menuItem
    -l "Polygons" 
    -c "da_TogglePolyVis" 
	-cb (`modelEditor -q -polymeshes $panel`)
    -rp "N";

menuItem
    -l "Light" 
    -c "da_ToggleLightVis" 
	-cb (`modelEditor -q -lights $panel`)
    -rp "NW";

menuItem
    -l "Joint" 
    -c "da_ToggleJointVis" 
	-cb (`modelEditor -q -joints $panel`)
    -rp "SE";

menuItem
    -l "IK Handle" 
    -c "da_ToggleIkVis" 
	-cb (`modelEditor -q -ikHandles $panel`)
    -rp "S";

menuItem
    -l "Locator" 
    -c "da_ToggleLocVis" 
	-cb (`modelEditor -q -locators $panel`);

menuItem
    -l "Deformers" 
    -c "da_ToggleDefVis" 
	-cb (`modelEditor -q -deformers $panel`)
    -rp "W";

menuItem
    -l "Nurbs" 
    -c "da_ToggleNurbsVis" 
	-cb (`modelEditor -q -nurbsSurfaces $panel`)
    -rp "E";

setParent -m ..;

menuItem
    -l "UI Elements" 
    -subMenu 1
    -rp "NW" 
	-i "out_displayLayer.png";

menuItem
    -l "Shelf" 
    -c "ToggleShelf" 
    -rp "SW" 
    -cb (`workspaceControl -q -vis Shelf`);

menuItem
    -l "Shelf Tabs" 
    -c "toggleShelfTabs" 
    -rp "W" 
    -cb (`optionVar -q shelfTabsVisible`);

menuItem
    -l "Menu Bars" 
    -c "TogglePanelMenubar" 
    -rp "NE" 
    -cb (`optionVar -q allowMenusInPanels`);

menuItem
    -l "Icon Bars" 
    -c "ToggleModelEditorBars" 
    -rp "NW" 
    -cb (false == `optionVar -q collapseIconBarsInPanels`);

menuItem
    -l "Main Menu Bars" 
    -c "ToggleMainMenubar" 
    -rp "E" 
    -cb (`optionVar -q mainWindowMenubarVis`);

menuItem
    -l "Title Bar" 
    -c "da_TitleBarToggle" 
    -rp "N" 
    -cb (`window -q -titleBar MayaWindow`);

menuItem
    -l "Save Workspace" 
    -c "workspaceLayoutManager -s" 
    -i "fileSave.png"
    -rp "S";

menuItem
	-c "SaveCurrentWorkspace" 
	-ob 1;

setParent -m ..;

menuItem
    -l "Shading" 
    -subMenu 1
    -rp "SE" 
	-i "WireFrameOnShaded.png";

menuItem
    -l "Wireframe on Shaded" 
    -c "da_ToggleWireOnShade" 
    -rp "SE"  
    -cb (`modelEditor -q -wos $panel`);

menuItem
    -l "Two Sided Lighting" 
    -c "da_ToggleTwoSidedLighting" 
    -rp "S" 
    -cb (`modelEditor -q -tsl $panel`);

menuItem
    -l "X-Ray Active Components" 
    -c "da_ToggleActiveComponentsXray" 
    -rp "E" 
    -cb (`modelEditor -q -acx $panel`);

menuItem
    -l "X-Ray Joints" 
    -c "da_ToggleJointXray" 
    -rp "NE" 
    -cb (`modelEditor -q -jx $panel`);

setParent -m ..;

menuItem
    -l "Viewport" 
    -subMenu 1
    -rp "SW" 
	-i "MultisampleAA.png";

menuItem
    -l "Anti-Aliasing" 
    -c "da_AntiAliasToggle" 
    -rp "SW" 
    -cb (`getAttr "hardwareRenderingGlobals.multiSampleEnable"`);

menuItem
    -l "Transparent Shadow" 
    -c "da_TransparentShadowsToggle" 
    -rp "SE" 
    -cb (`getAttr "hardwareRenderingGlobals.transparentShadow"`);

menuItem
    -l "Motion Blur" 
    -c "da_motionBlurEnableToggle" 
    -rp "S" 
    -cb (`getAttr "hardwareRenderingGlobals.motionBlurEnable"`);

menuItem
    -l "Grid" 
    -c "ToggleGrid" 
    -rp "NW" 
    -cb (`optionVar -q showGrid`);

menuItem
	-c "GridOptions" 
	-ob 1;

menuItem
    -l "Ambient Occlusion" 
    -c "da_ToggleAO" 
    -rp "W" 
    -cb (`getAttr "hardwareRenderingGlobals.ssaoEnable"`);

setParent -m ..;

}


// da_curveToPoly

global proc da_curveToPoly(){
	//Main Procedure
	string $renderCurve[] = `ls -sl`;
	ResetTemplateBrush;
	select $renderCurve;
	AttachBrushToCurves;
	string $renderCurveRelatives[] = `listRelatives $renderCurve`;
	string $renderStroke[] = `listConnections -t stroke -sh 1 -d 1 -s 0 $renderCurveRelatives`;
	select $renderStroke;
	doPaintEffectsToPoly( 1,0,1,1,100000);
	hyperShade -assign initialShadingGroup;

	//CTRL Procedure
	string $renderBrush[] = `listConnections -t brush $renderStroke`;
	string $locatorCTRL[] = `CreateLocator`;
	rename $locatorCTRL polyCurveCTRL1;
	string $showCTLR[] = `ls -sl`;
	addAttr -ln "Radius"  -at double  -min 0.001 -dv 0.5 $showCTLR;
	addAttr -ln "Clipping"  -at double  -min 0 -max 1 -dv 1 $showCTLR;
	addAttr -ln "Section"  -at long  -min 3 -max 12 -dv 4 $showCTLR;
	addAttr -ln "Density"  -at double -min 0.001 -max 20 -dv 1 $showCTLR;
	addAttr -ln "PolyLimit"  -at long  -min 1000 -max 1000000 -dv 100000 $showCTLR;
	addAttr -ln "HardEdges"  -at bool;
	setAttr -e-keyable true ($showCTLR[0] + ".Radius");
	setAttr -e-keyable true ($showCTLR[0] + ".Clipping");
	setAttr -e-keyable true ($showCTLR[0] + ".Section");
	setAttr -e-keyable true ($showCTLR[0] + ".Density");
	setAttr -e-keyable true ($showCTLR[0] + ".PolyLimit");
	setAttr -e-keyable true ($showCTLR[0] + ".HardEdges");
	int $numObj = size($renderBrush);
	for($i=0; $i<$numObj; $i++) connectAttr($locatorCTRL[0] + ".Radius", $renderBrush[$i] + ".brushWidth");
	for($i=0; $i<$numObj; $i++) connectAttr($locatorCTRL[0] + ".Section", $renderBrush[$i] + ".tubeSections");
	int $numObj2 = size($renderStroke);
	for($i=0; $i<$numObj2; $i++) connectAttr($locatorCTRL[0] + ".Clipping", $renderStroke[$i] + ".maxClip");
	for($i=0; $i<$numObj2; $i++) connectAttr($locatorCTRL[0] + ".Density", $renderStroke[$i] + ".sampleDensity");
	for($i=0; $i<$numObj2; $i++) connectAttr($locatorCTRL[0] + ".PolyLimit", $renderStroke[$i] + ".meshPolyLimit");
	for($i=0; $i<$numObj2; $i++) connectAttr($locatorCTRL[0] + ".HardEdges", $renderStroke[$i] + ".meshHardEdges");

	//Rig Procedure
	string $renderMesh[] = `listConnections -t mesh $renderStroke`;
	select $renderMesh;
	pickWalk -d up;
	string $groupMesh[] = `ls -sl`;
	parent $groupMesh $showCTLR;
	parent $renderStroke $showCTLR;
	select $showCTLR;

	//Clean Rig
	setAttr -e-keyable false -l true ($showCTLR[0] + ".tx");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".ty");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".tz");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".rx");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".ry");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".rz");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".sx");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".sy");
	setAttr -e-keyable false -l true ($showCTLR[0] + ".sz");
}


// da_interactiveBooleans

global proc da_wireframeTemplate(){
	string $myBoolOperators[] = `ls -sl`;
	string $myBool[] = `listConnections -s 1 -d 0 -sh 1`;
	select $myBool;
	for ($i=0; $i<size($myBool); $i++) {
		setAttr ($myBool[$i] + ".intermediateObject") 0;
		setAttr ($myBool[$i] + ".primaryVisibility") 0;
		setAttr ($myBool[$i] + ".overrideEnabled") 1;
		setAttr ($myBool[$i] + ".overrideShading") 0;
		setAttr ($myBool[$i] + ".visibility") 1;
		setAttr ($myBool[$i] + ".castsShadows") 0;
		setAttr ($myBool[$i] + ".receiveShadows") 0;
		setAttr ($myBool[$i] + ".motionBlur") 0;
		setAttr ($myBool[$i] + ".smoothShading") 0;
		setAttr ($myBool[$i] + ".visibleInReflections") 0;
		setAttr ($myBool[$i] + ".visibleInRefractions") 0;
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInDiffuseReflection") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInSpecularReflection") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInDiffuseTransmission") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInSpecularTransmission") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInVolume") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiSelfShadows") 0`);
	}

	showHidden -a;
	select $myBoolOperators;
}

global proc da_wireframeTemplateA(){
	string $myBoolOperators[] = `ls -sl`;
	string $myBool[] = `listConnections -s 1 -d 0 -sh 1`;
	select $myBool;
	for ($i=0; $i<size($myBool); $i++) {
		setAttr ($myBool[1] + ".intermediateObject") 0;
		setAttr ($myBool[1] + ".primaryVisibility") 0;
		setAttr ($myBool[1] + ".overrideEnabled") 1;
		setAttr ($myBool[1] + ".overrideShading") 0;
		setAttr ($myBool[1] + ".visibility") 1;
		setAttr ($myBool[1] + ".castsShadows") 0;
		setAttr ($myBool[1] + ".receiveShadows") 0;
		setAttr ($myBool[1] + ".motionBlur") 0;
		setAttr ($myBool[1] + ".smoothShading") 0;
		setAttr ($myBool[1] + ".visibleInReflections") 0;
		setAttr ($myBool[1] + ".visibleInRefractions") 0;
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInDiffuseReflection") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInSpecularReflection") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInDiffuseTransmission") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInSpecularTransmission") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInVolume") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiSelfShadows") 0`);
	}

	showHidden -a;
	select $myBoolOperators;
}

global proc da_wireframeTemplateB(){
	string $myBoolOperators[] = `ls -sl`;
	string $myBool[] = `listConnections -s 1 -d 0 -sh 1`;
	select $myBool;
	for ($i=0; $i<size($myBool); $i++) {
		setAttr ($myBool[0] + ".intermediateObject") 0;
		setAttr ($myBool[0] + ".primaryVisibility") 0;
		setAttr ($myBool[0] + ".overrideEnabled") 1;
		setAttr ($myBool[0] + ".overrideShading") 0;
		setAttr ($myBool[0] + ".visibility") 1;
		setAttr ($myBool[0] + ".castsShadows") 0;
		setAttr ($myBool[0] + ".receiveShadows") 0;
		setAttr ($myBool[0] + ".motionBlur") 0;
		setAttr ($myBool[0] + ".smoothShading") 0;
		setAttr ($myBool[0] + ".visibleInReflections") 0;
		setAttr ($myBool[0] + ".visibleInRefractions") 0;
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInDiffuseReflection") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInSpecularReflection") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInDiffuseTransmission") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInSpecularTransmission") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiVisibleInVolume") 0`);
		catchQuiet (`setAttr ($myBool[0] + ".aiSelfShadows") 0`);
	}

	showHidden -a;
	select $myBoolOperators;
}

global proc da_interactiveUnion(){
	string $myBoolOp[] = `polyCBoolOp -op 1 -ch 1 -pcr 0 -cls 1`;
	polyMergeVertex  -d 0.001 -am 1 -ch 1 polySurface1;
	select $myBoolOp[1];
	da_wireframeTemplate;
	ShowManipulators;
}

global proc da_interactiveDifference(){
	string $myBoolOp[] = `polyCBoolOp -op 2 -ch 1 -pcr 0 -cls 1`;
	polyMergeVertex  -d 0.001 -am 1 -ch 1 polySurface1;
	select $myBoolOp[1];
	da_wireframeTemplate;
	ShowManipulators;
}

global proc da_interactiveIntersection(){
	string $myBoolOp[] = `polyCBoolOp -op 3 -ch 1 -pcr 0 -cls 1`;
	polyMergeVertex  -d 0.001 -am 1 -ch 1 polySurface1;
	select $myBoolOp[1];
	da_wireframeTemplate;
	ShowManipulators;
}

// da_perspToggle

global proc da_perspToggle(){
	string $curPanel;
	string $curCam;
	int $orthoValue;
	float $camRot[];
	float $camRotTemp;
	int $intOfTemp;
	float $rotOver;
	float $camRotFixed[2];

	$curPanel = `getPanel -wf`;
	$curCam = `modelPanel -q -cam $curPanel`;
	$orthoValue = `camera -q -o $curCam`;

	if ($orthoValue == 1){
		setAttr ($curCam +".orthographic") 0;
		da_PasteCameraPosition;
		viewFit -f 0.5;

		inViewMessage -pos topCenter -msg "Perspective View" -fade;
		
	} else {

		da_CopyCameraPosition;
	
		$camRot = `camera -q -rot $curCam`;

		for ($i=0; $i < 2; $i++){
		
			$camRotTemp = $camRot[$i] / 360;
			$intOfTemp = (int)$camRotTemp;
			$rotOver = 360 * $intOfTemp;
			$camRotFixed[$i] = $camRot[$i] - $rotOver;
		}

		for ($i=0; $i < 2; $i++){
			if ($camRotFixed[$i] < 0)
				$camRotFixed[$i] += 360;
		}

		if ($camRotFixed[0] >= 45 && $camRotFixed[0] < 135){
			viewSet -bo;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Bottom position - Orthographic View" -fade;
		}

		else if ($camRotFixed[0] >= 225 && $camRotFixed[0] < 315){
			viewSet -t;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Top position - Orthographic View" -fade;
		}

		else if ($camRotFixed[1] < 45){
			viewSet -f;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Front position - Orthographic View" -fade;
		}

		else if ($camRotFixed[1] >= 315 ){
			viewSet -f;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Front position - Orthographic View" -fade;
		}

		else if ($camRotFixed[1] >= 45 && $camRotFixed[1] < 135)
		{
			viewSet -rs;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Right position - Orthographic View" -fade;
		}

		else if ($camRotFixed[1] >= 135 && $camRotFixed[1] < 225)
		{
			viewSet -b;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Back position - Orthographic View" -fade;
		}

		else if ($camRotFixed[1] >= 225 && $camRotFixed[1] < 315)
		{
			viewSet -ls;
			viewFit -f 0.5;
			inViewMessage -pos topCenter -msg "Left position - Orthographic View" -fade;
		}
	}
}


// da_shell

global proc da_shell(){
	string $myTransform[] = `ls -sl -typ "transform"`;
	string $myShape[] = `listRelatives -s`;
	catchQuiet (`duplicate`);
	string $myShell[] = `listRelatives -s`;
	connectAttr -f ($myShape[0] + ".outMesh") ($myShell[0] + ".inMesh");
	
	string $myShellTransform[] = `listRelatives -p $myShell`;
	select $myShellTransform;
	da_ResetTweakPoint;
	
	polyNormal -normalMode 0 -userNormalMode 0 -ch 1 $myShell;
	polyExtrudeFacet -tk 1;
	select $myShell;
	string $myPolyExtrudeFace[] = `listConnections -s 1 -d 0 -t "polyExtrudeFace"`;
	polyBevel3 -f 0.1 -oaf 1 -af 1 -d 1 -m 0 -mia 0 -c 1 -sg 1 -ws 1 -sa 30 -sn 1 -mv 1 -mvt 0.0001 -ma 180 -at 180 -ch 1;
	string $myPolyBevel[] = `listConnections -s 1 -d 0 -t "polyBevel3"`;

	setAttr ($myShell[0] +".overrideEnabled") 1;
	setAttr ($myShell[0] +".overrideDisplayType") 2;

	setAttr ($myShape[0] + ".primaryVisibility") 0;
	setAttr ($myShape[0] + ".overrideEnabled") 1;
	setAttr ($myShape[0] + ".overrideShading") 0;
	setAttr ($myShape[0] + ".visibility") 1;
	setAttr ($myShape[0] + ".castsShadows") 0;
	setAttr ($myShape[0] + ".receiveShadows") 0;
	setAttr ($myShape[0] + ".motionBlur") 0;
	setAttr ($myShape[0] + ".smoothShading") 0;
	setAttr ($myShape[0] + ".visibleInReflections") 0;
	setAttr ($myShape[0] + ".visibleInRefractions") 0;

	addAttr -ln "Thickness"  -at double  -min 0.001 -dv 1 $myTransform;
	addAttr -ln "Bevel"  -at "enum" -en "On:Off:" $myTransform;
	addAttr -ln "Chamfer"  -at bool $myTransform;
	addAttr -ln "Offset"  -at double  -min 0.001 -dv 0.1 $myTransform;
	addAttr -ln "Segments"  -at long  -min 1 -dv 1 $myTransform;
	setAttr -e-keyable true ($myTransform[0] + ".Thickness");
	setAttr -e-keyable true ($myTransform[0] + ".Bevel");
	setAttr -e-keyable true ($myTransform[0] + ".Chamfer") 1;
	setAttr -e-keyable true ($myTransform[0] + ".Offset");
	setAttr -e-keyable true ($myTransform[0] + ".Segments");

	connectAttr -f ($myTransform[0] + ".Thickness") ($myPolyExtrudeFace[0] + ".thickness");
	connectAttr -f ($myTransform[0] + ".Offset") ($myPolyBevel[0] + ".offset");
	connectAttr -f ($myTransform[0] + ".Segments") ($myPolyBevel[0] + ".segments");
	connectAttr -f ($myTransform[0] + ".Chamfer") ($myPolyBevel[0] + ".chamfer");
	connectAttr -f ($myTransform[0] + ".Bevel") ($myPolyBevel[0] + ".nodeState");
	
	select $myShell;
	pickWalk -d up;
	rename da_shell1;

	select $myTransform;
	rename da_shellBase1;
}

global proc da_shellDetach(){
	da_BackToObjectMode;

    string $myTransform[] = `ls -sl -typ "transform"`;
	string $myShape[] = `listRelatives -s`;

	setAttr ($myShape[0] + ".primaryVisibility") 1;
	setAttr ($myShape[0] + ".overrideEnabled") 0;
	setAttr ($myShape[0] + ".overrideShading") 1;
	setAttr ($myShape[0] + ".visibility") 1;
	setAttr ($myShape[0] + ".castsShadows") 1;
	setAttr ($myShape[0] + ".receiveShadows") 1;
	setAttr ($myShape[0] + ".motionBlur") 1;
	setAttr ($myShape[0] + ".smoothShading") 1;
	setAttr ($myShape[0] + ".visibleInReflections") 1;
	setAttr ($myShape[0] + ".visibleInRefractions") 1;

	string $myPolyBevel[] = `listConnections -s 0 -d 1 -t "polyBevel3"`;
	select $myPolyBevel[0];
	string $myShell[] = `listConnections -sh 1 -s 0 -d 1`;

	setAttr ($myShell[0] +".overrideEnabled") 1;
	setAttr ($myShell[0] +".overrideDisplayType") 0;
	
	deleteAttr ($myTransform[0] + ".Thickness");
	deleteAttr ($myTransform[0] + ".Bevel");
	deleteAttr ($myTransform[0] + ".Chamfer");
	deleteAttr ($myTransform[0] + ".Offset");
	deleteAttr ($myTransform[0] + ".Segments");

	select $myShape;
	pickWalk -d up;
	rename da_exShellBase1;

	select $myShell;
	pickWalk -d up;
	rename da_extractShell1;
	da_ClearFreeze;
}

global proc da_shellSubdiv(){
    string $myTransform[] = `ls -sl -typ "transform"`;
	string $myPolyBevel[] = `listConnections -s 0 -d 1 -t "polyBevel3"`;
	select $myPolyBevel[0];
	string $myShell[] = `listConnections -sh 1 -s 0 -d 1`;
	
	select $myShell;
    HighQualityDisplay;
    
    select $myTransform;
}

global proc da_shellNoSubdiv(){
    string $myTransform[] = `ls -sl -typ "transform"`;
	string $myPolyBevel[] = `listConnections -s 0 -d 1 -t "polyBevel3"`;
	select $myPolyBevel[0];
	string $myShell[] = `listConnections -sh 1 -s 0 -d 1`;
	
	select $myShell;
    LowQualityDisplay;
    
    select $myTransform;
}


// da_XGenBrushMangement

global proc da_XGenBrushMangement_MirrorOff(){

	string $CheckTool = `currentCtx`;

	if ($CheckTool == "xgmDensityBrushTool")
		xgmDensityBrushContext -e -bst 0 `currentCtx`;

	else if ($CheckTool == "xgmPlaceBrushTool")
		xgmPlaceBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmLengthBrushTool")
		xgmLengthBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmCutBrushTool")
		xgmCutBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmWidthBrushTool")
		xgmWidthBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmDirectionBrushTool")
		xgmDirectionBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmCombBrushTool")
		xgmCombBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmGrabBrushTool")
		xgmGrabBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmSmoothBrushTool")
		xgmSmoothBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmNoiseBrushTool")
		xgmNoiseBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmClumpBrushTool")
		xgmClumpBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmPartBrushTool")
		xgmPartBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmFreezeBrushTool")
		xgmFreezeBrushContext -e -bst 0 `currentCtx`;
		
	else if ($CheckTool == "xgmSelectBrushTool")
		xgmSelectBrushContext -e -bst 0 `currentCtx`;
		
	else
		print "Brush not supported";
}

global proc da_XGenBrushMangement_MirrorX(){

	string $CheckTool = `currentCtx`;

	if ($CheckTool == "xgmDensityBrushTool")
		xgmDensityBrushContext -e -bst 1 `currentCtx`;

	else if ($CheckTool == "xgmPlaceBrushTool")
		xgmPlaceBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmLengthBrushTool")
		xgmLengthBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmCutBrushTool")
		xgmCutBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmWidthBrushTool")
		xgmWidthBrushContext -e -bst 1 `currentCtx`;

	else if ($CheckTool == "xgmDirectionBrushTool")
		xgmDirectionBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmCombBrushTool")
		xgmCombBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmGrabBrushTool")
		xgmGrabBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmSmoothBrushTool")
		xgmSmoothBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmNoiseBrushTool")
		xgmNoiseBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmClumpBrushTool")
		xgmClumpBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmPartBrushTool")
		xgmPartBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmFreezeBrushTool")
		xgmFreezeBrushContext -e -bst 1 `currentCtx`;
		
	else if ($CheckTool == "xgmSelectBrushTool")
		xgmSelectBrushContext -e -bst 1 `currentCtx`;
		
	else
		print "Brush not supported";
}

global proc da_XGenBrushMangement_MirrorY(){

	string $CheckTool = `currentCtx`;

	if ($CheckTool == "xgmDensityBrushTool")
		xgmDensityBrushContext -e -bst 2 `currentCtx`;

	else if ($CheckTool == "xgmPlaceBrushTool")
		xgmPlaceBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmLengthBrushTool")
		xgmLengthBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmCutBrushTool")
		xgmCutBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmWidthBrushTool")
		xgmWidthBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmDirectionBrushTool")
		xgmDirectionBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmCombBrushTool")
		xgmCombBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmGrabBrushTool")
		xgmGrabBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmSmoothBrushTool")
		xgmSmoothBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmNoiseBrushTool")
		xgmNoiseBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmClumpBrushTool")
		xgmClumpBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmPartBrushTool")
		xgmPartBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmFreezeBrushTool")
		xgmFreezeBrushContext -e -bst 2 `currentCtx`;
		
	else if ($CheckTool == "xgmSelectBrushTool")
		xgmSelectBrushContext -e -bst 2 `currentCtx`;
		
	else
		print "Brush not supported";
}

global proc da_XGenBrushMangement_MirrorZ(){

	string $CheckTool = `currentCtx`;

	if ($CheckTool == "xgmDensityBrushTool")
		xgmDensityBrushContext -e -bst 3 `currentCtx`;

	else if ($CheckTool == "xgmPlaceBrushTool")
		xgmPlaceBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmLengthBrushTool")
		xgmLengthBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmCutBrushTool")
		xgmCutBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmWidthBrushTool")
		xgmWidthBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmDirectionBrushTool")
		xgmDirectionBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmCombBrushTool")
		xgmCombBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmGrabBrushTool")
		xgmGrabBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmSmoothBrushTool")
		xgmSmoothBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmNoiseBrushTool")
		xgmNoiseBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmClumpBrushTool")
		xgmClumpBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmPartBrushTool")
		xgmPartBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmFreezeBrushTool")
		xgmFreezeBrushContext -e -bst 3 `currentCtx`;
		
	else if ($CheckTool == "xgmSelectBrushTool")
		xgmSelectBrushContext -e -bst 3 `currentCtx`;
		
	else
		print "Brush not supported";
}

global proc da_XGenBrushMangement_CollisionOn(){

	string $CheckTool = `currentCtx`;

	if ($CheckTool == "xgmDensityBrushTool")
		xgmDensityBrushContext -e -ec 1`currentCtx`;

	else if ($CheckTool == "xgmPlaceBrushTool")
		xgmPlaceBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmLengthBrushTool")
		xgmLengthBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmCutBrushTool")
		xgmCutBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmWidthBrushTool")
		xgmWidthBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmDirectionBrushTool")
		xgmDirectionBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmCombBrushTool")
		xgmCombBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmGrabBrushTool")
		xgmGrabBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmSmoothBrushTool")
		xgmSmoothBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmNoiseBrushTool")
		xgmNoiseBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmClumpBrushTool")
		xgmClumpBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmPartBrushTool")
		xgmPartBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmFreezeBrushTool")
		xgmFreezeBrushContext -e -ec 1 `currentCtx`;
		
	else if ($CheckTool == "xgmSelectBrushTool")
		xgmSelectBrushContext -e -ec 1 `currentCtx`;
		
	else
		print "Brush not supported";
}

global proc da_XGenBrushMangement_CollisionOff(){

	string $CheckTool = `currentCtx`;

	if ($CheckTool == "xgmDensityBrushTool")
		xgmDensityBrushContext -e -ec 0`currentCtx`;

	else if ($CheckTool == "xgmPlaceBrushTool")
		xgmPlaceBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmLengthBrushTool")
		xgmLengthBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmCutBrushTool")
		xgmCutBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmWidthBrushTool")
		xgmWidthBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmDirectionBrushTool")
		xgmDirectionBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmCombBrushTool")
		xgmCombBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmGrabBrushTool")
		xgmGrabBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmSmoothBrushTool")
		xgmSmoothBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmNoiseBrushTool")
		xgmNoiseBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmClumpBrushTool")
		xgmClumpBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmPartBrushTool")
		xgmPartBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmFreezeBrushTool")
		xgmFreezeBrushContext -e -ec 0 `currentCtx`;
		
	else if ($CheckTool == "xgmSelectBrushTool")
		xgmSelectBrushContext -e -ec 0 `currentCtx`;
		
	else
		print "Brush not supported";
}


// da_FacesFollicles

global proc da_FacesFollicles()
{
    createHair 8 8 3 0 0 0 0 5 0 2 1 2;
	string $startSelect[] = `ls -sl`;
	convertHairSelection( "hairSystems" );
	string $hsys[] = `ls -sl`;
	if( size( $hsys ) < 1 ){
		warning( (uiRes("m_deleteEntireHairSystem.kNoHairSystemForDelete")) );
		select -r $startSelect;
		return;
	}

    convertHairSelection( "follicles" );
    string $follicles[] = `ls -sl`;
    Unparent;
    Group;
    rename "FacesFollicles1";
	convertHairSelection( "startCurves" );
	string $startCurves[] = `ls -sl`;
	select -r $follicles;
	convertHairSelection( "restCurves" );
	string $restCurves[] = `ls -sl`;
	select -r $follicles;
	convertHairSelection( "current" );
	string $current[] = `ls -sl`;
	select -r $follicles;
	convertHairSelection( "constraints" );
	string $constraints[] = `ls -sl`;
	clear $follicles;
	string $hsysGroups[];
	int $i, $j = 0;
	for( $i = 0; $i < size( $hsys ); $i++ ){
		string $tforms[] = listTransforms( $hsys[$i] );
		if( size( $tforms ) > 0 ){
			$hsysGroups[$j] = $tforms[0];
			$j++;
		}
		string $groups[] = getHairSystemGroups( $hsys[$i], false );
		if( $groups[0] != "" ){
			$hsysGroups[$j] = $groups[0];
			$j++;
		}
		if( $groups[1] != "" ){
			$hsysGroups[$j] = $groups[1];
			$j++;
		}
	}
	
	if(`pluginInfo -q -l Fur`) {	
		for( $i = 0; $i < size( $hsys ); $i++ ){
			string $curveAttractorSet[] = `listConnections -shapes true -type "FurCurveAttractors" $hsys[$i]`;
			if(size($curveAttractorSet) == 1)
				HfDeleteCAS $curveAttractorSet[0];
		}
	}

	string $all[];
	appendStringArray( $all, $hsys, size($hsys));
	appendStringArray( $all, $startCurves, size($startCurves));
	appendStringArray( $all, $restCurves, size($restCurves));
	appendStringArray( $all, $current, size($current));
	appendStringArray( $all, $constraints, size($constraints));
	appendStringArray( $all, $hsysGroups, size($hsysGroups));
	delete $all;
	select -r;
}


// da_Compass

global proc da_Compass(){
	circle -c 0 0 0 -nr 0 1 0 -sw 180 -r 0.5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
	string $myVectorDir1[] = `ls -sl`;
	setAttr ($myVectorDir1[0] + ".sx") -2;
	setAttr ($myVectorDir1[0] + ".sz") 0.02;
	da_ClearFreeze;

	duplicate;
	string $myVectorDir2[] = `ls -sl`;
	setAttr ($myVectorDir2[0] + ".rx") 90;
	da_ClearFreeze;

	circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 0.5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1;
	string $myVectorDir3[] = `ls -sl`;
	setAttr ($myVectorDir3[0] + ".rz") 90;
	setAttr ($myVectorDir3[0] + ".sx") 0.02;
	setAttr ($myVectorDir3[0] + ".sy") 0.02;
	setAttr ($myVectorDir3[0] + ".sz") 0.02;
	da_ClearFreeze;

	select $myVectorDir1[0] $myVectorDir2[0] $myVectorDir3[0];
	da_CombineCurves;
	xform -ws -a -rp 0 0 0;
	rename CompassVector1;
	string $myCompassVector[] = `ls -sl`;
	setAttr ($myCompassVector[0] + ".overrideEnabled") 1;
	setAttr ($myCompassVector[0] + ".overrideColor") 4;

	string $myVectorProduct = `createNode vectorProduct`;
	setAttr ($myVectorProduct + ".operation") 3;
	setAttr ($myVectorProduct + ".input1X") 1;
		
	string $myMultiplyDivide = `createNode multiplyDivide`;

	connectAttr ($myCompassVector[0] + ".worldMatrix[0]", $myVectorProduct + ".matrix");

	addAttr -ln "VectorX" -at double $myCompassVector[0];
	addAttr -ln "VectorY" -at double $myCompassVector[0];
	addAttr -ln "VectorZ" -at double $myCompassVector[0];
	addAttr -ln "Magnitude" -at double $myCompassVector[0];
	setAttr -e -k 1 ($myCompassVector[0] + ".VectorX");
	setAttr -e -k 1 ($myCompassVector[0] + ".VectorY");
	setAttr -e -k 1 ($myCompassVector[0] + ".VectorZ");
	setAttr -e -k 1 ($myCompassVector[0] + ".Magnitude" ) 1;
	setAttr -l 1 ($myCompassVector[0] + ".sx");
	setAttr -l 1 ($myCompassVector[0] + ".sy");
	setAttr -l 1 ($myCompassVector[0] + ".sz");
		
		
	connectAttr($myVectorProduct + ".output.outputX", $myMultiplyDivide + ".input1.input1X");
	connectAttr($myVectorProduct + ".output.outputY", $myMultiplyDivide + ".input1.input1Y");
	connectAttr($myVectorProduct + ".output.outputZ", $myMultiplyDivide + ".input1.input1Z");
		
	connectAttr($myMultiplyDivide + ".output.outputX", $myCompassVector[0] + ".VectorX");
	connectAttr($myMultiplyDivide + ".output.outputY", $myCompassVector[0] + ".VectorY");
	connectAttr($myMultiplyDivide + ".output.outputZ", $myCompassVector[0] + ".VectorZ");
		
	connectAttr($myCompassVector[0] + ".Magnitude", $myMultiplyDivide + ".input2.input2X");
	connectAttr($myCompassVector[0] + ".Magnitude", $myMultiplyDivide + ".input2.input2Y");
	connectAttr($myCompassVector[0] + ".Magnitude", $myMultiplyDivide + ".input2.input2Z");

	select $myCompassVector[0];
}


// da_AntiAlias

global proc da_AntiAliasToggle(){
	if(`getAttr "hardwareRenderingGlobals.multiSampleEnable"`){
    	setAttr "hardwareRenderingGlobals.multiSampleEnable" 0;
	}else{
	    setAttr "hardwareRenderingGlobals.multiSampleEnable" 1;
	}
}

// da_JointMode

global proc da_JointMode(){
	if(`selectMode -q -component`){
    	changeSelectMode -object;
	}else{
	    changeSelectMode -component;
    	setComponentPickMask "Other" 1;
	}
}

// da_TransparentShadows

global proc da_TransparentShadowsToggle(){
	if(`getAttr "hardwareRenderingGlobals.transparentShadow"`){
    	setAttr "hardwareRenderingGlobals.transparentShadow" 0;
	}else{
	    setAttr "hardwareRenderingGlobals.transparentShadow" 1;
	}
}

// da_motionBlurEnable

global proc da_motionBlurEnableToggle(){
	if(`getAttr "hardwareRenderingGlobals.motionBlurEnable"`){
    	setAttr "hardwareRenderingGlobals.motionBlurEnable" 0;
	}else{
	    setAttr "hardwareRenderingGlobals.motionBlurEnable" 1;
	}
}

// da_ToggleAO

global proc da_ToggleAO(){
	if(`getAttr "hardwareRenderingGlobals.ssaoEnable"`){
    	setAttr "hardwareRenderingGlobals.ssaoEnable" 0;
	}else{
	    setAttr "hardwareRenderingGlobals.ssaoEnable" 1;
	}
}


// da_maxPlaybackSpeed

global proc da_maxPlaybackSpeedToggle(){
	if(`playbackOptions -q -maxPlaybackSpeed`){
    	playbackOptions -e -playbackSpeed 0 -maxPlaybackSpeed 0;
	}else{
	    playbackOptions -e -playbackSpeed 0 -maxPlaybackSpeed 1;
	}
}

// da_steppedPreview

global proc da_steppedPreview(){
	if(`playbackOptions -q -blockingAnim`){
    	playbackOptions -e -blockingAnim 0;
	}else{
	    playbackOptions -e -blockingAnim 1;
	}
}


// da_vertexAnimationCache

global proc da_vertexAnimationCache(){
	if(`getAttr "hardwareRenderingGlobals.vertexAnimationCache"`){
    	setAttr "hardwareRenderingGlobals.vertexAnimationCache" 0;
	}else{
	    setAttr "hardwareRenderingGlobals.vertexAnimationCache" 2;
	}
}

// da_TitleBarToggle

global proc da_TitleBarToggle(){
	if(`window -q -titleBar MayaWindow`){
    	window -e -titleBar 0 MayaWindow;
	}else{
	    window -e -titleBar 1 MayaWindow;
	}
}


// da_SculptFlood

global proc da_SculptFlood(){
	string $myCurrentTool = `currentCtx`;
	float $myStrengthValue = `sculptMeshCacheCtx -q -strength $myCurrentTool`;
	sculptMeshCacheCtx -e -flood $myStrengthValue $myCurrentTool;
}


// buildSelectAllMM

global proc buildSelectAllMM(){
    if( `popupMenu -exists tempMM` )
    {
        deleteUI tempMM;
    }

	global string $MMcmd;

	$MMcmd = "";
	
    popupMenu -mm 1 -b 1 -aob 1 -p `findPanelPopupParent` -pmc ("$MMcmd = \"Posted\"") tempMM;

	menuItem -rp "W" -l (uiRes("m_buildSelectAllMM.kSelectAllInputs"))  
		-c "$MMcmd = \"selectHistory\"";
	menuItem -rp "E" -l (uiRes("m_buildSelectAllMM.kSelectAllOutputs"))  
		-c "$MMcmd = \"selectFuture\"";

	menuItem -rp "N" -l (uiRes("m_buildSelectAllMM.kEnableAllOutputs"))  
		-c "$MMcmd = \"enableFuture\"";
	menuItem -rp "S" -l (uiRes("m_buildSelectAllMM.kDisableAllOutputs"))  
		-c "$MMcmd = \"disableFuture\"";

	menuItem -rp "NW" -l (uiRes("m_buildSelectAllMM.kDeleteHistory"))  
		-c "$MMcmd = \"deleteHistory\"" -version "2015";
	menuItem -rp "NE" -l (uiRes("m_buildSelectAllMM.kDeleteNonDeformerHistory"))  
		-c "$MMcmd = \"deleteNDHistory\"" -version "2015";

	menuItem -rp "SE" -l (uiRes("m_buildSelectAllMM.kFreezeTransforms"))  
		-c "$MMcmd = \"freezeTransformations\"" ;

	menuItem
		-l (uiRes("m_buildSelectAllMM.kFreezeTransformsOptions"))
		-c "$MMcmd = \"freezeTransformationsOptions\""
		-optionBox 1
		-rp "SE" ;

	if (`pluginInfo -q -loaded SOuP` == 1){
		python("smartConnect_SOuP().main()") ;
	}

	setParent -m ..;
}

global proc buildSelectAllMM_release(){
	global string $MMcmd;

	if ($MMcmd != "") {
		//	Process Marking menu selection
		switch ($MMcmd) {
			case "selectHistory" :
				selectAllInputOutput false;
				break;
			case "selectFuture" :
				selectAllInputOutput true;
				break;
			case "enableFuture" :
				disableOfSelected 1 0;
				break;
			case "disableFuture" :
				disableOfSelected 1 1;
				break;
			case "deleteHistory" :
				DeleteHistory;
				break;
			case "deleteNDHistory" :
				BakeNonDefHistory;
				break;
			case "freezeTransformations" :
				FreezeTransformations;
				break;
			case "freezeTransformationsOptions" :
				FreezeTransformationsOptions;
				break;
		}
		$MMcmd = "Processed";
	} 
	
	if( `popupMenu -exists tempMM` ) {
		deleteUI tempMM;
	} 
	
	if ($MMcmd == "") {
		FrameAll;
	}
}


// da_pivotKeyable

global proc da_pivotKeyable(){
	string $myTransform[] = `ls -sl -type "transform"`;

	for ($each in $myTransform){
	    setAttr -k on ($each + ".rotatePivotX");
	    setAttr -k on ($each + ".rotatePivotY");
	    setAttr -k on ($each + ".rotatePivotZ");
	    
	    setAttr -k on ($each + ".rotatePivotTranslateX");
	    setAttr -k on ($each + ".rotatePivotTranslateY");
	    setAttr -k on ($each + ".rotatePivotTranslateZ");    
	}
}


// da_moveKeyframe

global proc da_moveKeyframeToNext(){
	int $currentTime = `currentTime -q`;
	keyframe -t `currentTime -q` -e -r -tc 1;
	NextFrame;
}

global proc da_moveKeyframeToPrev(){
	int $currentTime = `currentTime -q`;
	keyframe -t `currentTime -q` -e -r -tc -1;
	PreviousFrame;
}


// da_roundKeyframe

global proc da_roundKeyframe(){
	string $animCurves[] = `keyframe -q -name`;
	for ($animCurve in $animCurves){
		float $thisKeys[] = `keyframe -q -sl $animCurve`;
		if (!size($thisKeys))
			$thisKeys = `keyframe -q $animCurve`;
		for ($keys in $thisKeys)
		{
			if (`fmod $keys 1` != 0)
				keyframe -e -t $keys -iub true -a -o over -timeChange (da_round($keys)) $animCurve;
		}
	}
}


// da_weightedTangents

global proc da_weightedTangents(){
    int $weightedTangentsCheck[] = `keyTangent -q -weightedTangents`;
    int $weightedTangentsSum = 0;

    for ($each in $weightedTangentsCheck)
		$weightedTangentsSum += $each;
    
    if($weightedTangentsSum){
    	keyTangent -e -weightedTangents 0;
	}else{
	    keyTangent -e -weightedTangents 1;
	}
}

// da_breakTangents

global proc da_breakTangents(){
    int $breakTangentsCheck[] = `keyTangent -q -lock`;
    int $breakTangentsSum = 0;

    for ($each in $breakTangentsCheck)
		$breakTangentsSum += $each;
    
    if($breakTangentsSum){
    	keyTangent -e -lock 0;
	}else{
	    keyTangent -e -lock 1;
	}
}


// da_InseritKeyframe

global proc da_InseritKeyframe(){
	string $curves[] = `keyframe -q -selected -name`;
	int $i;
	for ($i = 0; $i < size($curves); $i++){
			float $curTime = `animCurveEditor -keyingTime $curves[$i] -q graphEditor1GraphEd`;
			if ( size($curves) ) setKeyframe -time $curTime -insert $curves[$i];
	}
}


// da_MatchNormals

global proc da_MatchNormals(){
    string $myRefNormals[] = `ls -sl -tail 1`;
    string $myTargets[] = stringArrayRemove(`ls -sl -tail 1`, `ls -sl -fl`);
    int $numObj = size($myTargets);
    for($i=0; $i<$numObj; $i++) transferAttributes -pos 0 -nml 1 -uvs 0 -col 0 -spa 0 -sm 3 -clb 1 $myRefNormals[0] $myTargets[$i];
}


// da_MatchUV

global proc da_MatchUV(){
    string $myRefUV[] = `ls -sl -tail 1`;
    string $myTargets[] = stringArrayRemove(`ls -sl -tail 1`, `ls -sl -fl`);
    int $numObj = size($myTargets);
    for($i=0; $i<$numObj; $i++) transferAttributes -pos 0 -nml 0 -uvs 1 -col 0 -spa 0 -sm 3 -clb 1 $myRefUV[0] $myTargets[$i];
}

// da_SelectShellFromFaces

global proc da_SelectShellFromFaces(){
	ConvertSelectionToUVs;
	SelectUVShell;
	ConvertSelectionToFaces;
}


// da_ShowLocalAxis

global proc da_ShowLocalAxis(){
	string $mySel[] = `ls -sl`;
	int $numObj = size($mySel);
    for($i=0; $i<$numObj; $i++) setAttr ($mySel[$i] + ".displayLocalAxis") 1;
}

// da_HideLocalAxis

global proc da_HideLocalAxis(){
	string $mySel[] = `ls -sl`;
	int $numObj = size($mySel);
    for($i=0; $i<$numObj; $i++) setAttr ($mySel[$i] + ".displayLocalAxis") 0;
}


// da_FreezeDelNonDef

global proc da_FreezeDelNonDef(){
	FreezeTransformations;
	BakeNonDefHistory;
}


// da_Emitter

global proc da_EmitterDirectional(){
	string $mySel[] = `ls -sl`;
	for ($each in $mySel)
	setAttr ($each +".emitterType") 0;
}

global proc da_EmitterOmni(){
	string $mySel[] = `ls -sl`;
	for ($each in $mySel)
	setAttr ($each +".emitterType") 1;
}

global proc da_EmitterVolume(){
	string $mySel[] = `ls -sl`;
	for ($each in $mySel)
	setAttr ($each +".emitterType") 4;
}

global proc da_EmitterCompass(){
	string $myEmitter[] = `ls -sl`;
	da_Compass;
	string $myDirection[] = `ls -sl`;

	for ($each in $myEmitter){
		connectAttr($myDirection[0] + ".VectorX", $each + ".directionX");
		connectAttr($myDirection[0] + ".VectorY", $each + ".directionY");
		connectAttr($myDirection[0] + ".VectorZ", $each + ".directionZ");
	}
}


// da_nClothCompass

global proc da_nClothForceCompass(){
	string $myNcloth[] = `ls -sl`;

	da_Compass;
	string $myDirection[] = `ls -sl`;

	for ($each in $myNcloth){
		connectAttr($myDirection[0] + ".VectorX", $each + ".localForce.localForceX");
		connectAttr($myDirection[0] + ".VectorY", $each + ".localForce.localForceY");
		connectAttr($myDirection[0] + ".VectorZ", $each + ".localForce.localForceZ");
	}
}

global proc da_nClothWindCompass(){
	string $myNcloth[] = `ls -sl`;

	da_Compass;
	string $myDirection[] = `ls -sl`;

	for ($each in $myNcloth){
		connectAttr($myDirection[0] + ".VectorX", $each + ".localWind.localWindX");
		connectAttr($myDirection[0] + ".VectorY", $each + ".localWind.localWindY");
		connectAttr($myDirection[0] + ".VectorZ", $each + ".localWind.localWindZ");
	}
}


// da_MapFacesUV

global proc da_MapFacesUV(){
	string $myResult = `confirmDialog -title "Confirm" -message "This command create a per face UV shell and Freeze Transformation, continue?" 
	-button "Yes" -button "No" -defaultButton "Yes" 
	-cancelButton "No" -dismissString "No"`;
	if ($myResult == "Yes"){
	    string $mySel[] = `ls -sl`;
	    $mySelSize = size($mySel);
	    for($i=0; $i<$mySelSize; $i++){
	        select $mySel[$i];
	    	FreezeTransformations;
	    	polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0;
	    	dR_DoCmd("modeEdge");
	    	SelectAll;
	    	CutUVs;
	    	u3dUnfold -ite 1 -p 0 -bi 1 -tf 1 -ms 1024 -rs 0;
	    	ConvertSelectionToUVs;
	    	uvTkDoSetTexelDensity;
	    	UVOrientShells;
	    	u3dLayout -res 256 -scl 1 -box 0 1 0 1;
	    	dR_modeObject;
	    }
	}
}

global proc da_MapFacesFacesUV(){
	string $myResult = `confirmDialog -title "Confirm" -message "This command create a per face UV shell and Freeze Transformation, continue?" 
	-button "Yes" -button "No" -defaultButton "Yes" 
	-cancelButton "No" -dismissString "No"`;
	if ($myResult == "Yes"){
		string $myFaces[] = `ls -sl`;
		da_BackToObjectMode;
		FreezeTransformations;
		dR_DoCmd("modePoly");
		select $myFaces;
		polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0;
		ConvertSelectionToEdges;
		CutUVs;
		select $myFaces;
		u3dUnfold -ite 1 -p 0 -bi 1 -tf 1 -ms 1024 -rs 0;
		UVOrientShells;
		polyMultiLayoutUV -lm 1 -sc 1 -rbf 1 -fr 1 -ps 0.2 -l 2 -gu 1 -gv 1 -psc 1 -su 1 -sv 1 -ou 0 -ov 0;
		dR_modeObject;
	}
}


// da_AiVolumes

global proc da_AiVolumes(){
	python("import mtoa.ui.arnoldmenu as arnoldmenu;arnoldmenu.createVolume()");
	PickWalkUp;

	string $mySelShape[] = `listRelatives -s`;
	string $shadingEngine = `createNode shadingEngine -n aiVolumeShapeSG1`;
	string $myStandardVolume = `createNode aiStandardVolume`;

	connectAttr -f ($mySelShape[0] + ".instObjGroups[0]") ($shadingEngine + ".dagSetMembers[0]");
	connectAttr -f ($myStandardVolume + ".outColor") ($shadingEngine + ".volumeShader");

	select $mySelShape[0];
	PickWalkUp;
}

global proc da_AiVolumeShader(){
	string $mySelShape[] = `listRelatives -s`;
	select $mySelShape[0];
	string $myShadingEngine[] = `listConnections -s 0 -d 1 -t "shadingEngine"`;
	select -r -ne $myShadingEngine[0];
	string $myAiStandardVolume[] = `listConnections -s 1 -d 0 -t "aiStandardVolume"`;
	select -r -ne $myAiStandardVolume[0];
	AttributeEditor;
}

global proc da_AiVolumeShapes(){
	string $mySelShape[] = `listRelatives -s`;
	select $mySelShape[0];
	AttributeEditor;
}


// da_RendereViews

global proc da_RendereViews(){
	if (`getAttr defaultRenderGlobals.currentRenderer` == "arnold"){
		python("import mtoa.ui.arnoldmenu as arnoldmenu; arnoldmenu.arnoldMtoARenderView()");
	}
	else if (`getAttr defaultRenderGlobals.currentRenderer` == "mayaSoftware"){
		RenderViewWindow;
		IPRRenderIntoNewWindow;
		renderWindowCheckAndRenderRegion 1 0 0 1;
	}else{ 
		RenderViewWindow;
	}

	inViewMessage -pos topCenter -msg "Starting Render" -fade;
}


// da_ImagesPlane

global proc da_ImagesPlane(){
	string $myPanel = `getPanel -underPointer`;
	string $myCamera = `modelPanel -q -cam $myPanel`;
	select $myCamera;
	string $myCameraShape[] = `listRelatives -s`;

	importImagePlane { $myCameraShape[0] };
}

// da_VideoImagesPlane

global proc da_VideoImagesPlane(){
	string $myPanel = `getPanel -underPointer`;
	string $myCamera = `modelPanel -q -cam $myPanel`;
	select $myCamera;
	string $myCameraShape[] = `listRelatives -s`;

	importMovieImagePlane { $myCameraShape[0] };
}

// da_CameraImagesPlane

global proc da_CameraImagesPlane(){
	string $myCameraShape[] = `listRelatives -s`;

	importImagePlane { $myCameraShape[0] };
}

// da_CameraVideoImagesPlane

global proc da_CameraVideoImagesPlane(){
	string $myCameraShape[] = `listRelatives -s`;

	importMovieImagePlane { $myCameraShape[0] };
}


// da_RemoveMrNodes

global proc da_RemoveMrNodes(){
	string $myResult = `confirmDialog -title "Confirm" -message "Did you want delete all Mental Ray Nodes?" 
	-button "Yes" -button "No" -defaultButton "Yes" 
	-cancelButton "No" -dismissString "No"`;

	if ($myResult == "Yes") {
		catchQuiet (`delete miDefaultOptions`);
		catchQuiet (`delete miContourPreset`);
		catchQuiet (`delete Draft`);
		catchQuiet (`delete DraftMotionBlur`);
		catchQuiet (`delete DraftRapidMotion`);
		catchQuiet (`delete Preview`);
		catchQuiet (`delete PreviewMotionblur`);
		catchQuiet (`delete PreviewRapidMotion`);
		catchQuiet (`delete PreviewCaustics`);
		catchQuiet (`delete PreviewGlobalIllum`);
		catchQuiet (`delete PreviewFinalGather`);
		catchQuiet (`delete Production`);
		catchQuiet (`delete ProductionMotionblur`);
		catchQuiet (`delete ProductionRapidMotion`);
		catchQuiet (`delete ProductionFineTrace`);
		catchQuiet (`delete ProductionRapidFur`);
		catchQuiet (`delete ProductionRapidHair`);

		catchQuiet (`delete miDefaultFramebuffer`);
		catchQuiet (`delete mentalrayItemsList`);

		catchQuiet (`delete "mapViz*"`);
		catchQuiet (`delete "mentalrayIblShape*"`);

		unknownPlugin -remove "Mayatomr";
		inViewMessage -pos topCenter -msg "Mental Ray nodes deleted" -fade;
	}
}